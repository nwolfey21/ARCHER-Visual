/*******************************************************************

Air Force Research Labs Advanced Electric Lasers Branch

********************************************************************

Discription:
  This is the main program for the NLSE USPL propagation simulation 
    complete with GUI

Version: 2.2

Currently: 6/13/13
  Everything Initialized and working. 
  All comments removed.
  All tabbed out.
  Commandline and GUI separate functionality added.
  First attempt at adding new display windows.

*******************************************************************/
/* Propagation Code Headers */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <time.h>
#include <string.h>
#include <complex.h>

/* OpenGL Code Headers */
#include <GL/glui.h>

/*************External Functions***************/
// Updated
void runSim(int crap);
void runSimNoGUI(int crap);
float * initialize(int *sn, int *prints, int propDistance, int rDomain, int xDomain, int yDomain, int tDomain, int zDomain, int iflag, int inlambda0, int inrmax, int intmax, int show_cart, int inLCR, int taup, int w0, float inEnergy, int inpf, float inchirp, char *outDirectory);
void finalize();
void drawTemporal( int x1, float x2, float y1, float y2, int flag);
void openglinit();
float drawSpatial(int N, int flag);
void drawSpectral( int N, int flag);
void drawSpaceTime( int N, int flag);
void drawMaxIntensity( int N, int flag);
float drawBeamWaist( int N, int flag);
void plasmaDecay(int nr, int nt, int step_num, double intmax, double inconsp3, char *directory);

/*************Internal Functions***************/
void realtimeDisplay( void );
void draw_temporal_axes(float scale);
void spatialReshape( int x, int y );
void spatialDisplay( void );
void spectralDisplayInit( void );
void spectralDisplay( void );
void spacetimeDisplayInit( void );
void spacetimeDisplay( void );
void maxIntensityDisplayInit( void );
void maxIntensityDisplay( void );
void beamWaistDisplayInit( void );
void beamWaistDisplay( void );

float elapsed_cpu;

float version = 3.93;
float xy_aspect;
int   last_x, last_y;
float rotationX = 0.0, rotationY = 0.0;

/** Time Variables **/
clock_t start, end, endi, intermediate;

/** Propagation variables **/
int flag[12];
int prints[10];
int propDistance = 100;
int rDomain = 640;
int xDomain = 0;
int yDomain = 0;
int tDomain = 640;
int zDomain = 1/*10000*/;
int inrmax = 20;
int intmax = 200;
int inlambda0 = 800;
int inLCR = 60;
float inchirp = -5.75;
float inEnergy = 35;
int inpf = 0;
int inw0 = 10;
int intaup = 55;
int mt;			// current z step
int flagInit = 0;
float *values;
float powr = 0;
float ener = 0;
float diameter = 0;
float tPlasMax = 1.67;
int tPlasDomain = 100;
float tDecay = 2.77;
char *Directory;

/** These are the live variables passed into GLUI ***/
int   wireframe = 0;
int   obj_type = 1;
int   segments = 8;
int   segments2 = 8;
int   light0_enabled = 1;
int   light1_enabled = 1;
float light0_intensity = 1.0;
float light1_intensity = .4;
int   temporalWindow;
int   spatialWindow;
int   spectralWindow;
int   spacetimeWindow;
int   maxIntensityWindow;
int   beamWaistWindow;
int   realtimeWindow;
float scale = 1.0;
int   show_sphere=1;
int   show_torus=1;
int   show_axes = 1;
int   show_text = 1;
int   show_diffraction=1;
int   show_stf=0;
int   show_dispersion=1;
int   show_spm=1;
int   show_ss=0;
int   show_mpi=1;
int   show_plasma=1;
int   show_lens=1;
int   show_raman=0;
int   show_avalanche=1;
int   show_cyl=1;
int   show_cart=0;
int   show_spatial=0;
int   show_temporal=0;
int   show_space=0;
int   show_spectral=0;
int   show_beam=1;
int   show_max=1;
int   print_spatDom=1;
int   print_plasDom=1;
int   print_spatVid=1;
int   print_plasVid=1;
int   print_plasSim=1;
int   input_pf=0;
int   input_energy=1;
float spatial_rotate[16] = { 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 };
float view_spatial_rotate[16] = { 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 };
float spatial_pos[] = { 0.0, 0.0, 0.0 };
float spectral_rotate[16] = { 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 };
float view_spectral_rotate[16] = { 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 };
float spectral_pos[] = { 0.0, 0.0, 0.0 };
float spacetime_rotate[16] = { 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 };
float view_spacetime_rotate[16] = { 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 };
float spacetime_pos[] = { 0.0, 0.0, 0.0 };
float maxIntensity_pos[] = { 0.0, 0.0, 0.0 };
float beamWaist_pos[] = { 0.0, 0.0, 0.0 };
float maxIntensity_rotate[16] = { 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 };
float view_maxIntensity_rotate[16] = { 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 };
float beamWaist_rotate[16] = { 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 };
float view_beamWaist_rotate[16] = { 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 };
float temporal_rotate[16] = { 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 };
float view_temporal_rotate[16] = { 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 };
float temporal_pos[] = { 0.0, 0.0, 0.0 };
float sphere_rotate[16] = { 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 };
float torus_rotate[16] = { 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 };
float view_rotate[16] = { 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 };
float obj_pos[] = { 0.0, 0.0, 0.0 };
char  strDistance[17] = "Distance: 0cm";
char  strEnergy[20] = "Energy: 0.0 mJ";
char  strPower[20] = "Power: 0.0 GW";
char  strIntensity[26] = "Intensity: 0.0 arb";
char  strDiameter[20] = "Beam Waist: cm";
char  strTimeLeft[28] = "Time Remaining: 0 secs";
char  strTimeRunning[30] = "Elapsed Time: 0 secs";
char pulseString_list[15] = "Gaussian";
char wavelengthString_list[10] = "800";
int   curr_string = 0;

/** Pointers to the windows and some of the controls we'll create **/
GLUI            *spectralRightSubWindow, *spatialSubWindow, *spectralSubWindow, *temporalBottomSubWIndow, *controlWindow, *spacetimeSubWindow, *maxIntensitySubWindow, *propSubWindow, *beamWaistSubWindow;
GLUI            *realtimeTopSubWindow, *realtimeBottomSubWindow;
GLUI_Spinner    *light0_spinner, *light1_spinner;
GLUI_StaticText *text, *energy, *power, *intensity, *energyval, *powerval, *intensityval;
GLUI_StaticText *indistance, *distanceval, *radius, *radiusval;
GLUI_RadioGroup *radio;
GLUI_Panel      *obj_panel, *properties_panel, *control_panel;
GLUI_Panel      *realtime_top_panel, *realtime_bottom_panel;
GLUI_EditText   *fwhmText;

/********** User IDs for callbacks ********/
#define LIGHT0_ENABLED_ID    200
#define LIGHT1_ENABLED_ID    201
#define LIGHT0_INTENSITY_ID  250
#define LIGHT1_INTENSITY_ID  260
#define ENABLE_ID            300
#define DISABLE_ID           301
#define SHOW_ID              302
#define HIDE_ID              303
#define INITIALIZE           231
#define PROPAGATE	     232
#define PAUSE		     233
#define DECAY	     	     234

/********** Miscellaneous global variables **********/
GLfloat light0_ambient[] =  {0.1f, 0.1f, 0.3f, 1.0f};
GLfloat light0_diffuse[] =  {.6f, .6f, 1.0f, 1.0f};
GLfloat light0_position[] = {.5f, .5f, 1.0f, 0.0f};

GLfloat light1_ambient[] =  {0.1f, 0.1f, 0.3f, 1.0f};
GLfloat light1_diffuse[] =  {.9f, .6f, 0.0f, 1.0f};
GLfloat light1_position[] = {-1.0f, -1.0f, 1.0f, 0.0f};

GLfloat lights_rotation[16] = {1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 };


/***********************************************************************/
/*                          reshapeTemporal()                           */
/*                      Reshapes the Temporal window                    */
/***********************************************************************/
void reshapeTemporal(int w, int h)
{
	printf("temporalReshape\n");
	float ww = glutGet(GLUT_WINDOW_WIDTH);
	float wh = glutGet(GLUT_WINDOW_HEIGHT);
	glViewport(1, 1, ww, wh);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
printf("poop\n");
	glOrtho(-.05, 1, -.25, 1, -1, 1);
	glMatrixMode(GL_MODELVIEW);
};


/***********************************************************************/
/*                          redrawTemporal()                           */
/*                      Redraws the Temporal window                    */
/***********************************************************************/
void redrawTemporal()
{
	printf("redrawingTemporal\n");
	glClearColor( .9f, .9f, .9f, 1.0f );
	glClear(GL_COLOR_BUFFER_BIT);
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	if ( flagInit>0 )
	{
		drawTemporal(0, tDomain, 0, 1.01, show_temporal);			// x-axis and y-axis
	}
	reshapeTemporal(400,400);
printf("crappy\n");
  	if ( flagInit>0 )
	{
    		draw_temporal_axes(1.0f);
	}
	glutSwapBuffers();
};


/***********************************************************************/
/*                          control_cb()                               */
/*                      GLUI control callback                          */
/***********************************************************************/
void control_cb( int control )
{
	printf("control_cb \n");
	if ( control == LIGHT0_ENABLED_ID ) 
	{
		if ( light0_enabled ) 
		{
			glEnable( GL_LIGHT0 );
			light0_spinner->enable();
		}
		else 
		{
			glDisable( GL_LIGHT0 ); 
			light0_spinner->disable();
		}
	}
	else if ( control == LIGHT1_ENABLED_ID ) 
	{
		if ( light1_enabled ) 
		{
			glEnable( GL_LIGHT1 );
			light1_spinner->enable();
		}
		else 
		{
			glDisable( GL_LIGHT1 ); 
			light1_spinner->disable();
		}
	}
	else if ( control == LIGHT0_INTENSITY_ID ) 
	{
		float v[] = {light0_diffuse[0], light0_diffuse[1], light0_diffuse[2], light0_diffuse[3]};
		v[0] *= light0_intensity;
		v[1] *= light0_intensity;
		v[2] *= light0_intensity;
		glLightfv(GL_LIGHT0, GL_DIFFUSE, v );
	}
	else if ( control == LIGHT1_INTENSITY_ID ) 
	{
		float v[] = {light1_diffuse[0], light1_diffuse[1], light1_diffuse[2], light1_diffuse[3]};
		v[0] *= light1_intensity;
		v[1] *= light1_intensity;
		v[2] *= light1_intensity;
		glLightfv(GL_LIGHT1, GL_DIFFUSE, v );
	}
	else if ( control == ENABLE_ID )
	{
		temporalBottomSubWIndow->enable();			// Enables temporalBottomSubWindow (controls)
	}
	else if ( control == DISABLE_ID )
	{
		temporalBottomSubWIndow->disable();			// disables temporalBottomSubWindow (controls)
	}
	else if ( control == SHOW_ID )
	{
		temporalBottomSubWIndow->show();			// disables temporalBottomSubWindow (controls)
	}
	else if ( control == HIDE_ID )
	{
		temporalBottomSubWIndow->hide();			// disables temporalBottomSubWindow (controls)
	}
	else if ( control == INITIALIZE )
	{
		flagInit = 1;
		flag[0] = show_diffraction;
		flag[1] = show_spm;
		flag[2] = show_dispersion;
		flag[3] = show_mpi;
		flag[4] = show_ss;
		flag[5] = show_plasma;
		flag[6] = show_lens;
		flag[7] = 0;
		flag[8] = input_pf;
		flag[9] = input_energy;
		prints[0] = print_spatDom;	//Print Spatial Domain
		prints[1] = print_plasDom;	//Print Plasma Domain
		prints[2] = print_spatVid;	//Print Spatial Video
		prints[3] = print_plasVid;	//Print Plasma Video
		prints[4] = print_plasSim;	//Print Plasma Lifecycle
		values = initialize(flag, prints, propDistance, rDomain, xDomain, yDomain, tDomain, zDomain, 1, inlambda0, inrmax, intmax, show_cyl, inLCR, intaup, inw0, inEnergy, inpf, inchirp, Directory);
//		printf("Crappy\n");
		powr = values[0];
		ener = values[1];
		sprintf(strPower, "Power: %.2f GW", powr*1e-9);
		sprintf(strEnergy, "Energy: %.2f mJ", ener*1e3);
//		printf("Crappy\n");
		glutSetWindow(temporalWindow);
		redrawTemporal();		
		glutSetWindow(spatialWindow);
		spatialDisplay();	
		glutSetWindow(spacetimeWindow);
		spacetimeDisplayInit();	
		glutSetWindow(spectralWindow);
		spectralDisplayInit();	
		glutSetWindow(realtimeWindow);
		realtimeDisplay();
		glutSetWindow(maxIntensityWindow);
		maxIntensityDisplayInit();	
		glutSetWindow(beamWaistWindow);
		beamWaistDisplayInit();			
	}
	else if ( control == PROPAGATE ) 	// avalanche
	{
		printf("\n\n--------------Propagate------------\n");
		int mod;
		int mod2;
		int mod2Rate = 50;
		float avgtime;
		float timeleft;
		start = clock();
		intermediate = clock();
		for( mt = 1; mt <= zDomain; mt++)
//		for( mt = 1; mt <= 1; mt++)
		{
			mod2 = mt % mod2Rate;
//	printf("Crap2\n");
			if(mod2 == 0)
			{
				endi = clock();
				avgtime = (double)(endi-start) / mt;
				timeleft = ((zDomain - (float)mt)) * avgtime;
			    	sprintf(strTimeLeft, "Time Remaining: %.2f secs", timeleft/CLOCKS_PER_SEC);
				intermediate = endi;
			}
//	printf("Crap3\n");
//printf("here\n");
//			intermediate = clock();
			mod = mt % 1;
//printf("here\n");
			if(mod == 0)
			{
				sprintf(strDistance, "Distance: %.2fcm", (float)mt*((float)propDistance)/zDomain);
			}
//printf("here\n");
			glutSetWindow(temporalWindow);
//printf("here1\n");
			runSim(mt);
//printf("here12\n");
			if( control == PAUSE )
			{
				break;
			}
			mod = mt % 1;
			if(mod == 0)
			{
				end = clock();	
				elapsed_cpu = ((double) (end - start)) / CLOCKS_PER_SEC*2.0;
				sprintf(strTimeRunning, "Elapsed Time: %.2f secs", elapsed_cpu);
				glutSetWindow(temporalWindow);
				redrawTemporal();	
				glutSetWindow(spatialWindow);
				spatialDisplay();
				glutSetWindow(spectralWindow);
				spectralDisplay();
				glutSetWindow(realtimeWindow);
				realtimeDisplay();
				glutSetWindow(spacetimeWindow);
				spacetimeDisplay();
				glutSetWindow(maxIntensityWindow);
				maxIntensityDisplay();
				glutSetWindow(beamWaistWindow);
				beamWaistDisplay();
			}
//	printf("Crap1\n");
		}
		printf("elapsed time for matrix exponential on cpu = %f seconds \n", elapsed_cpu);		
		finalize();			
	}
	else if ( control == DECAY ) 	// avalanche
	{
		printf("\n\n--------------Plasma Decay------------\n");
		start = clock();
		intermediate = clock();
		plasmaDecay(rDomain, tDomain, zDomain, tPlasMax, tDecay, Directory); 
	}
}


/***********************************************************************/
/*                         myGlutKeyboard()                            */
/***********************************************************************/
void myGlutKeyboard(unsigned char Key, int x, int y)
{
	printf("myglutkeyboard \n");
	switch(Key)
	{
		case 27: 
		case 'q':
			exit(0);
		break;
	};
	glutPostRedisplay();
}


/***********************************************************************/
/*                           myGlutMenu()                              */
/***********************************************************************/
void myGlutMenu( int value )
{
	printf("myglutmenu \n");
	myGlutKeyboard( value, 0, 0 );
}


/***********************************************************************/
/*                           myGlutIdle()                              */
/***********************************************************************/
void myGlutIdle( void )
{
	printf("myglutidle \n");
	if ( glutGetWindow() != temporalWindow ) 
		glutSetWindow(temporalWindow);  
	glutPostRedisplay();
}


/***********************************************************************/
/*                           myGlutMouse()                             */
/***********************************************************************/
void myGlutMouse(int button, int button_state, int x, int y )
{
	printf("myglutmouse \n");
}


/***********************************************************************/
/*                           myGlutMotion()                            */
/***********************************************************************/
void myGlutMotion(int x, int y )
{
	printf("myglutmotion \n");
	glutPostRedisplay(); 
}


/***********************************************************************/
/*                           spatialReshape()                           */
/***********************************************************************/
void spatialReshape( int x, int y )
{
	printf("spatialReshape \n");
	glutSetWindow(spatialWindow);
	int tx, ty, tw, th;
	GLUI_Master.get_viewport_area( &tx, &ty, &tw, &th );
	glViewport( tx, ty, tw, th );
	xy_aspect = (float)tw / (float)th;
	glutPostRedisplay();
}


/***********************************************************************/
/*                           spectralReshape()                           */
/***********************************************************************/
void spectralReshape( int x, int y )
{
	printf("spectralReshape \n");
	glutSetWindow(spectralWindow);
	int tx, ty, tw, th;
	GLUI_Master.get_viewport_area( &tx, &ty, &tw, &th );
	glViewport( tx, ty, tw, th );
	xy_aspect = (float)tw / (float)th;
	glutPostRedisplay();
}


/***********************************************************************/
/*                           spacetimeReshape()                           */
/***********************************************************************/
void spacetimeReshape( int x, int y )
{
	printf("spacetimeReshape ");
	glutSetWindow(spacetimeWindow);
	int tx, ty, tw, th;
	GLUI_Master.get_viewport_area( &tx, &ty, &tw, &th );
	glViewport( tx, ty, tw, th );
	xy_aspect = (float)tw / (float)th;
	glutPostRedisplay();
}


/***********************************************************************/
/*                           maxIntensityReshape()                           */
/***********************************************************************/
void maxIntensityReshape( int x, int y )
{
	printf("maxIntensityReshape ");
	glutSetWindow(maxIntensityWindow);
	int tx, ty, tw, th;
	GLUI_Master.get_viewport_area( &tx, &ty, &tw, &th );
	glViewport( tx, ty, tw, th );
	xy_aspect = (float)tw / (float)th;
	glutPostRedisplay();
}


/***********************************************************************/
/*                           beamWaistReshape()                           */
/***********************************************************************/
void beamWaistReshape( int x, int y )
{
	printf("beamWaistReshape ");
	glutSetWindow(beamWaistWindow);
	int tx, ty, tw, th;
	GLUI_Master.get_viewport_area( &tx, &ty, &tw, &th );
	glViewport( tx, ty, tw, th );
	xy_aspect = (float)tw / (float)th;
	glutPostRedisplay();
}


/***********************************************************************/
/*                       draw_temporal_axes()                          */
/*               Disables lighting, then draws RGB axes                */
/***********************************************************************/
void draw_temporal_axes( float scale )
{
	printf("draw_temporal_axes\n");
	glDisable( GL_LIGHTING );
	glPushMatrix();
	glScalef( scale, scale, scale );
	glLineWidth(2.0); 
	glBegin( GL_LINES );
	/* Letter T */
	glColor3f( 1.0, 0.0, 0.0 );
	glVertex3f( 0.969f, -0.01f, 0.0 );  glVertex3f( 0.99, -0.01f, 0.0 ); 
	glVertex3f( 0.98f, -0.01f, 0.0 );   glVertex3f( 0.98, -0.045f, 0.0 );
	/* Letter I */
	glVertex3f( -0.01f, 0.990f, 0.0 );  glVertex3f( -0.03, 0.990f, 0.0 );
	glVertex3f( -0.02f, 0.990f, 0.0 );  glVertex3f( -0.02, 0.953f, 0.0 );
	glVertex3f( -0.01f, 0.953f, 0.0 );  glVertex3f( -0.03, 0.953f, 0.0 ); 
	/* X axis */
	glColor3f( 0.0, 0.0, 0.0 );
	glVertex3f( 0.0, 0.0, 0.0 );  glVertex3f( 1.0, 0.0, 0.0 ); 
	/* Y axis */
	glColor3f( 0.0, 0.0, 0.0 );
	glVertex3f( 0.0, 0.0, 0.0 );  glVertex3f( 0.0, 1.0, 0.0 ); 
	/* Z axis */
	glColor3f( 0.0, 0.0, 0.0 );
	glVertex3f( 0.0, 0.0, 0.0 );  glVertex3f( 0.0, 0.0, 1.0 ); 
	glEnd();
	glPopMatrix();
	glEnable( GL_LIGHTING );
}


/***********************************************************************/
/*                           draw_spatial_axes()                       */
/*               Disables lighting, then draws RGB axes                */
/***********************************************************************/
void draw_spatial_axes( float scale )
{
	printf("draw_spatial_axes\n");
	glDisable( GL_LIGHTING );
	glPushMatrix();
	glScalef( scale, scale, scale );
	glLineWidth(2.0); 
	glBegin( GL_LINES );
	/* Letter X */
	glColor3f( 1.0, 0.0, 0.0 );
	glVertex3f( 1.77f, -0.05f, 0.0 );  glVertex3f( 1.9, -0.25f, 0.0 ); 
	glVertex3f( 1.77f, -.25f, 0.0 );  glVertex3f( 1.9, -0.05f, 0.0 );
	/* Letter Y */
	glColor3f( 0.0, 0.0, 0.0 );
	glVertex3f( -0.05f, 1.85f, 0.0 );  glVertex3f( -0.1, 1.74f, 0.0 ); 
	glVertex3f( -0.15f, 1.85f, 0.0 );  glVertex3f( -0.1, 1.74f, 0.0 );
	glVertex3f( -0.1f, 1.6f, 0.0 );  glVertex3f( -0.1, 1.74f, 0.0 ); 
	/* X axis */
	glColor3f( 1.0, 0.0, 0.0 );
	glVertex3f( 0.0, 0.0, 0.0 );  glVertex3f( 2.0, 0.0, 0.0 ); 
	/* Y axis */
	glColor3f( 0.0, 0.0, 0.0 );
	glVertex3f( 0.0, 0.0, 0.0 );  glVertex3f( 0.0, 2.0, 0.0 ); 
	glEnd();
	glPopMatrix();
	glEnable( GL_LIGHTING );
}


/***********************************************************************/
/*                           draw_spacetime_axes()                       */
/*               Disables lighting, then draws RGB axes                */
/***********************************************************************/
void draw_spacetime_axes( float scale )
{
	printf("draw_spacetime_axes\n");
	glDisable( GL_LIGHTING );
	glPushMatrix();
	glScalef( scale, scale, scale );
	glTranslatef(-8.95, 0.0, 0.0);
	glLineWidth(2.0); 
	glBegin( GL_LINES );
	/* Letter Z */
	glColor3f( 1.0, 0.0, 0.0 );
	glVertex3f( 1.77, -0.05, 0.0 );  glVertex3f( 1.9, -0.05, 0.0 ); 
	glVertex3f( 1.9, -0.05, 0.0 );  glVertex3f( 1.77, -.25, 0.0 );
	glVertex3f( 1.77, -.25, 0.0 );  glVertex3f( 1.9, -.25, 0.0 ); 
	/* Letter X */
	glColor3f( 0.0, 0.0, 0.0 );
	glVertex3f( -0.05f, 1.85f, 0.0 );  glVertex3f( -0.15f, 1.6f, 0.0 ); 
	glVertex3f( -0.15f, 1.85f, 0.0 );  glVertex3f( -0.05f, 1.6f, 0.0 );
	/* X axis */
	glColor3f( 1.0, 0.0, 0.0 );
	glVertex3f( 0.0, 0.0, 0.0 );  glVertex3f( 2.0, 0.0, 0.0 ); 
	/* Y axis */
	glColor3f( 0.0, 0.0, 0.0 );
	glVertex3f( 0.0, 0.0, 0.0 );  glVertex3f( 0.0, 2.0, 0.0 ); 
	glEnd();
	glPopMatrix();
	glEnable( GL_LIGHTING );
}


/***********************************************************************/
/*                           draw_maxIntensity_axes()                       */
/*               Disables lighting, then draws RGB axes                */
/***********************************************************************/
void draw_maxIntensity_axes( float scale )
{
	printf("draw_maxIntensity_axes\n");
	glDisable( GL_LIGHTING );
	glPushMatrix();
	glScalef( scale, scale, scale );
	glTranslatef(-8.75, -1.8, 0.0);
	glLineWidth(2.0); 
	glBegin( GL_LINES );
	/* Letter Z */
	glColor3f( 1.0, 0.0, 0.0 );
	glVertex3f( 1.77, -0.05, 0.0 );  glVertex3f( 1.9, -0.05, 0.0 ); 
	glVertex3f( 1.9, -0.05, 0.0 );  glVertex3f( 1.77, -.25, 0.0 );
	glVertex3f( 1.77, -.25, 0.0 );  glVertex3f( 1.9, -.25, 0.0 ); 
	/* Letter X */
	glColor3f( 0.0, 0.0, 0.0 );
	glVertex3f( -0.05f, 1.85f, 0.0 );  glVertex3f( -0.15f, 1.6f, 0.0 ); 
	glVertex3f( -0.15f, 1.85f, 0.0 );  glVertex3f( -0.05f, 1.6f, 0.0 );
	/* X axis */
	glColor3f( 1.0, 0.0, 0.0 );
	glVertex3f( 0.0, 0.0, 0.0 );  glVertex3f( 2.0, 0.0, 0.0 ); 
	/* Y axis */
	glColor3f( 0.0, 0.0, 0.0 );
	glVertex3f( 0.0, 0.0, 0.0 );  glVertex3f( 0.0, 2.0, 0.0 ); 
	glEnd();
	glPopMatrix();
	glEnable( GL_LIGHTING );
}


/***********************************************************************/
/*                           draw_beamWaist_axes()                       */
/*               Disables lighting, then draws RGB axes                */
/***********************************************************************/
void draw_beamWaist_axes( float scale )
{
	printf("draw_beamWaist_axes\n");
	glDisable( GL_LIGHTING );
	glPushMatrix();
	glScalef( scale, scale, scale );
	glTranslatef(-8.95, 0.0, 0.0);
	glLineWidth(2.0); 
	glBegin( GL_LINES );
	/* Letter Z */
	glColor3f( 1.0, 0.0, 0.0 );
	glVertex3f( 1.77, -0.05, 0.0 );  glVertex3f( 1.9, -0.05, 0.0 ); 
	glVertex3f( 1.9, -0.05, 0.0 );  glVertex3f( 1.77, -.25, 0.0 );
	glVertex3f( 1.77, -.25, 0.0 );  glVertex3f( 1.9, -.25, 0.0 ); 
	/* Letter X */
	glColor3f( 0.0, 0.0, 0.0 );
	glVertex3f( -0.05f, 1.85f, 0.0 );  glVertex3f( -0.15f, 1.6f, 0.0 ); 
	glVertex3f( -0.15f, 1.85f, 0.0 );  glVertex3f( -0.05f, 1.6f, 0.0 );
	/* X axis */
	glColor3f( 1.0, 0.0, 0.0 );
	glVertex3f( 0.0, 0.0, 0.0 );  glVertex3f( 2.0, 0.0, 0.0 ); 
	/* Y axis */
	glColor3f( 0.0, 0.0, 0.0 );
	glVertex3f( 0.0, 0.0, 0.0 );  glVertex3f( 0.0, 2.0, 0.0 ); 
	glEnd();
	glPopMatrix();
	glEnable( GL_LIGHTING );
}


/***********************************************************************/
/*                           draw_spectral_axes()                       */
/*               Disables lighting, then draws RGB axes                */
/***********************************************************************/
void draw_spectral_axes( float scale )
{
	printf("draw_spectral_axes\n");
	glDisable( GL_LIGHTING );
	glPushMatrix();
	glScalef( scale, scale, scale );
	glLineWidth(2.0); 
	glBegin( GL_LINES );
	/* Letter Z */
	glColor3f( 1.0, 0.0, 0.0 );
	glVertex3f( 1.77, -0.05, 1.0 );  glVertex3f( 1.9, -0.05, 1.0 ); 
	glVertex3f( 1.9, -0.05, 1.0 );  glVertex3f( 1.77, -.25, 1.0 );
	glVertex3f( 1.77, -.25, 1.0 );  glVertex3f( 1.9, -.25, 1.0 ); 
	/* Letter X */
	glColor3f( 0.0, 0.0, 0.0 );
	glVertex3f( -0.05f, 1.85f, 1.0 );  glVertex3f( -0.15f, 1.6f, 1.0 ); 
	glVertex3f( -0.15f, 1.85f, 1.0 );  glVertex3f( -0.05f, 1.6f, 1.0 );
	/* Letter Y */
	glColor3f( 0.0, 0.0, 1.0 );
	glVertex3f( -0.05f, -0.05f, 1.0 );  glVertex3f( -0.1, -0.14f, 1.0 ); 
	glVertex3f( -0.15f, -0.05f, 1.0 );  glVertex3f( -0.1, -0.14f, 1.0 );
	glVertex3f( -0.1f, -0.28f, 1.0 );  glVertex3f( -0.1, -0.14f, 1.0 ); 
	/* X axis */
	glColor3f( 1.0, 0.0, 0.0 );
	glVertex3f( 0.0, 0.0, 1.0 );  glVertex3f( 2.0, 0.0, 1.0 ); 
	/* Y axis */
	glColor3f( 0.0, 0.0, 0.0 );
	glVertex3f( 0.0, 0.0, 1.0 );  glVertex3f( 0.0, 2.0, 1.0 ); 
	/* Z axis */
	glColor3f( 0.0, 0.0, 1.0 );
	glVertex3f( 0.0, 0.0, 1.0 );  glVertex3f( 0.01, 0.1, 1.5 ); 
	glEnd();
	glPopMatrix();
	glEnable( GL_LIGHTING );
}


/***********************************************************************/
/*                           draw_axes()                               */
/*               Disables lighting, then draws RGB axes                */
/***********************************************************************/
void draw_axes( float scale )
{
	printf("draw_axes");
	glDisable( GL_LIGHTING );
	glPushMatrix();
	glScalef( scale, scale, scale );
	glBegin( GL_LINES );
	/* Letter X */
	glColor3f( 1.0, 0.0, 0.0 );
	glVertex3f( .8f, 0.05f, 0.0 );  glVertex3f( 1.0, 0.25f, 0.0 ); 
	/* X axis */
	glVertex3f( 0.8f, .25f, 0.0 );  glVertex3f( 1.0, 0.05f, 0.0 );
	glVertex3f( 0.0, 0.0, 0.0 );  glVertex3f( 1.0, 0.0, 0.0 ); 
	/* Y axis */
	glColor3f( 0.0, 1.0, 0.0 );
	glVertex3f( 0.0, 0.0, 0.0 );  glVertex3f( 0.0, 1.0, 0.0 ); 
	/* Z axis */
	glColor3f( 0.0, 0.0, 1.0 );
	glVertex3f( 0.0, 0.0, 0.0 );  glVertex3f( 0.0, 0.0, 1.0 ); 
	glEnd();
	glPopMatrix();
	glEnable( GL_LIGHTING );
}


/***********************************************************************/
/*                           realtimeDisplay                           */
/***********************************************************************/
void realtimeDisplay( void )
{
	printf("realtimeDisplay \n");
	glClearColor( .9f, .9f, .9f, 1.0f );
	glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
	if ( show_text ) 
	{
		glDisable( GL_LIGHTING );  /* Disable lighting while we render text */
		glMatrixMode( GL_PROJECTION );
		glLoadIdentity();
		gluOrtho2D( 0.0, 100.0, 0.0, 11.0 );
		glMatrixMode( GL_MODELVIEW );
		glLoadIdentity();
		glLineWidth(3.0);
		glColor3ub( 0, 0, 0 );
		glRasterPos2i( 20, 9 );
		/*** Render the live character array 'text' ***/
		int i;
		for( i=0; i<(int)strlen( strDistance ); i++ )
		{
			glutBitmapCharacter( GLUT_BITMAP_HELVETICA_18, strDistance[i] );
		}
		glRasterPos2i( 55, 9 );			// (x,y)
		for( i=0; i<(int)strlen( strEnergy ); i++ )
		{
			glutBitmapCharacter( GLUT_BITMAP_HELVETICA_18, strEnergy[i] );
		}
		glRasterPos2i( 20, 7 );
		for( i=0; i<(int)strlen( strPower ); i++ )
		{
			glutBitmapCharacter( GLUT_BITMAP_HELVETICA_18, strPower[i] );
		}
		glRasterPos2i( 55, 7 );
		for( i=0; i<(int)strlen( strIntensity ); i++ )
		{
			glutBitmapCharacter( GLUT_BITMAP_HELVETICA_18, strIntensity[i] );
		}
		glRasterPos2i( 20, 5 );
		for( i=0; i<(int)strlen( strDiameter ); i++ )
		{
			glutBitmapCharacter( GLUT_BITMAP_HELVETICA_18, strDiameter[i] );
		}
		glRasterPos2i( 55, 5 );
		for( i=0; i<(int)strlen( strTimeLeft ); i++ )
		{
			glutBitmapCharacter( GLUT_BITMAP_HELVETICA_18, strTimeLeft[i] );
		}
		glRasterPos2i( 35, 3 );
		for( i=0; i<(int)strlen( strTimeRunning ); i++ )
		{
			glutBitmapCharacter( GLUT_BITMAP_HELVETICA_18, strTimeRunning[i] );
		}
	}
	glLineWidth(2.0);
	glEnable( GL_LIGHTING );
	glutSwapBuffers(); 
}


/***********************************************************************/
/*                           spatialDisplay()                           */
/***********************************************************************/
void spatialDisplay( void )
{
	float intensity = 0;
	printf("spatialDisplay \n");
	glClearColor( .9f, .9f, .9f, 1.0f );
	glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
	glMatrixMode( GL_PROJECTION );

	glLoadIdentity();
	glFrustum( -xy_aspect*.04, xy_aspect*.04, -.04, .04, .1, 15.0 );
	glMatrixMode( GL_MODELVIEW );

	glLoadIdentity();
	glMultMatrixf( lights_rotation );
	glLightfv(GL_LIGHT0, GL_POSITION, light0_position);

	glLoadIdentity();
	glTranslatef( 0.0, 0.0, -2.6f );
	glTranslatef( spatial_pos[0], spatial_pos[1], -spatial_pos[2] ); 
	glMultMatrixf( view_spatial_rotate );

	glScalef( scale, scale, scale );

	glPushMatrix();
	glTranslatef( 0.0, 0.0, 0.0 );
	glMultMatrixf( spatial_rotate );
	if ( flagInit>0 )
	{
		draw_spatial_axes(.52f);
	}

	glTranslatef( 0.0, 0.0, 0.0 );
	glMultMatrixf( spatial_rotate );
	if( flagInit>0 )
	{
		intensity = drawSpatial(mt, show_spatial);
	}
	sprintf(strIntensity, "Intensity: %f arb", intensity);	

	glEnable( GL_LIGHTING );

	glutSwapBuffers(); 
}


/***********************************************************************/
/*                           spectralDisplayInit()                           */
/***********************************************************************/
void spectralDisplayInit( void )
{
	printf("spectralDisplayInit\n");
	glClearColor( .9f, .9f, .9f, 1.0f );
	glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

	glMatrixMode( GL_PROJECTION );
	glLoadIdentity();
	glFrustum( -xy_aspect*.04, xy_aspect*.04, -.04, .04, .1, 15.0 );

	glMatrixMode( GL_MODELVIEW );

	glLoadIdentity();
	glMultMatrixf( lights_rotation );
	glLightfv(GL_LIGHT0, GL_POSITION, light0_position);

	glLoadIdentity();
	glTranslatef( 0.0, 0.0, -2.6f );
	glTranslatef( spectral_pos[0], spectral_pos[1], -spectral_pos[2] ); 
	glMultMatrixf( view_spectral_rotate );

	glScalef( scale, scale, scale );

	glPushMatrix();
	glTranslatef( 0.0, 0.0, 0.0 );
	glMultMatrixf( spectral_rotate );
	if ( flagInit>0 )
	{
		if ( show_axes )
			draw_spacetime_axes(.52f);
	}

	glTranslatef( 0.0, 0.0, 0.0 );
	glMultMatrixf( spectral_rotate );
	if ( flagInit>0 )
	{
		drawSpectral(mt, show_spectral);	
	}

	glEnable( GL_LIGHTING );

	glutSwapBuffers(); 
}


/***********************************************************************/
/*                           spectralDisplay()                           */
/***********************************************************************/
void spectralDisplay( void )
{
	printf("spectralDisplay \n");

	glMatrixMode( GL_PROJECTION );
	glLoadIdentity();
	glFrustum( -xy_aspect*.04, xy_aspect*.04, -.04, .04, .1, 15.0 );

	glMatrixMode( GL_MODELVIEW );

	glLoadIdentity();
	glMultMatrixf( lights_rotation );
	glLightfv(GL_LIGHT0, GL_POSITION, light0_position);

	glLoadIdentity();
	glTranslatef( 0.0, 0.0, -2.6f );
	glTranslatef( spectral_pos[0], spectral_pos[1], -spectral_pos[2] ); 
	glMultMatrixf( view_spectral_rotate );

	glScalef( scale, scale, scale );

	glPushMatrix();
	glTranslatef( 0.0, 0.0, 0.0 );

	glTranslatef( 0.0, 0.0, 0.0 );
	glMultMatrixf( spectral_rotate );
	if ( flagInit>0 )
	{
		drawSpectral(mt, show_spectral);
	}

	glEnable( GL_LIGHTING );

	glutSwapBuffers();
}


/***********************************************************************/
/*                           spacetimeDisplayInit()                           */
/***********************************************************************/
void spacetimeDisplayInit( void )
{
	printf("spacetimeDisplayInit\n");
	glClearColor( .9f, .9f, .9f, 1.0f );
	glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

	glMatrixMode( GL_PROJECTION );
	glLoadIdentity();
	glFrustum( -xy_aspect*.04, xy_aspect*.04, -.04, .04, .1, 15.0 );

	glMatrixMode( GL_MODELVIEW );

	glLoadIdentity();
	glMultMatrixf( lights_rotation );
	glLightfv(GL_LIGHT0, GL_POSITION, light0_position);

	glLoadIdentity();
	glTranslatef( 0.0, 0.0, -2.6f );
	glTranslatef( spacetime_pos[0], spacetime_pos[1], -spacetime_pos[2] ); 
	glMultMatrixf( view_spacetime_rotate );

	glScalef( scale, scale, scale );

	glPushMatrix();
	glTranslatef( 0.0, 0.0, 0.0 );
	glMultMatrixf( spacetime_rotate );
	if ( flagInit>0 )
	{
		if ( show_axes )
			draw_spacetime_axes(.52f);
	}

	glTranslatef( 0.0, 0.0, 0.0 );
	glMultMatrixf( spacetime_rotate );
	if( xDomain>0 )
	{
		drawSpaceTime(mt, show_space);
	}

	glEnable( GL_LIGHTING );

	glutSwapBuffers(); 
}


/***********************************************************************/
/*                           spacetimeDisplay()                           */
/***********************************************************************/
void spacetimeDisplay( void )
{
	printf("spacetimeDisplay ");

	glMatrixMode( GL_PROJECTION );
	glLoadIdentity();
	glFrustum( -xy_aspect*.04, xy_aspect*.04, -.04, .04, .1, 15.0 );

	glMatrixMode( GL_MODELVIEW );

	glLoadIdentity();
	glMultMatrixf( lights_rotation );
	glLightfv(GL_LIGHT0, GL_POSITION, light0_position);

	glLoadIdentity();
	glTranslatef( 0.0, 0.0, -2.6f );
	glTranslatef( spacetime_pos[0], spacetime_pos[1], -spacetime_pos[2] ); 
	glMultMatrixf( view_spacetime_rotate );

	glScalef( scale, scale, scale );

	glPushMatrix();
	glTranslatef( 0.0, 0.0, 0.0 );
	glMultMatrixf( spacetime_rotate );
	if ( xDomain>0 )
	{
		draw_spacetime_axes(.52f);
	}

	glTranslatef( 0.0, 0.0, 0.0 );
	glMultMatrixf( spacetime_rotate );
	if ( flagInit>0 )
	{
		drawSpaceTime( mt, show_space);
	}

	glEnable( GL_LIGHTING );

	glutSwapBuffers(); 
}


/***********************************************************************/
/*                           maxIntensityDisplayInit()                           */
/***********************************************************************/
void maxIntensityDisplayInit( void )
{
	printf("maxIntensityDisplayInit\n");
	glClearColor( .9f, .9f, .9f, 1.0f );
	glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

	glMatrixMode( GL_PROJECTION );
	glLoadIdentity();
	glFrustum( -xy_aspect*.04, xy_aspect*.04, -.04, .04, .1, 15.0 );

	glMatrixMode( GL_MODELVIEW );

	glLoadIdentity();
	glMultMatrixf( lights_rotation );
	glLightfv(GL_LIGHT0, GL_POSITION, light0_position);

	glLoadIdentity();
	glTranslatef( 0.0, 0.0, -2.6f );
	glTranslatef( maxIntensity_pos[0], maxIntensity_pos[1], -maxIntensity_pos[2] ); 
	glMultMatrixf( view_maxIntensity_rotate );

	glScalef( scale, scale, scale );

	glPushMatrix();
	glTranslatef( 0.0, 0.0, 0.0 );
	glMultMatrixf( maxIntensity_rotate );
	if ( flagInit>0 )
	{
		if ( show_axes )
			draw_maxIntensity_axes(.52f);
	}
	glTranslatef( 0.0, 0.0, 0.0 );
	glMultMatrixf( maxIntensity_rotate );
	if ( flagInit>0 )
	{
		drawMaxIntensity(mt, show_max);
	}
	glEnable( GL_LIGHTING );
	glutSwapBuffers(); 
}


/***********************************************************************/
/*                           beamWaistDisplayInit()                           */
/***********************************************************************/
void beamWaistDisplayInit( void )
{
	float diameter = 0;
	printf("beamWaistDisplayInit\n");
	glClearColor( .9f, .9f, .9f, 1.0f );
	glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

	glMatrixMode( GL_PROJECTION );
	glLoadIdentity();
	glFrustum( -xy_aspect*.04, xy_aspect*.04, -.04, .04, .1, 15.0 );

	glMatrixMode( GL_MODELVIEW );

	glLoadIdentity();
	glMultMatrixf( lights_rotation );
	glLightfv(GL_LIGHT0, GL_POSITION, light0_position);

	glLoadIdentity();
	glTranslatef( 0.0, 0.0, -2.6f );
	glTranslatef( beamWaist_pos[0], beamWaist_pos[1], -beamWaist_pos[2] ); 
	glMultMatrixf( view_beamWaist_rotate );

	glScalef( scale, scale, scale );

	glPushMatrix();
	glTranslatef( 0.0, 0.0, 0.0 );
	glMultMatrixf( beamWaist_rotate );
	if ( flagInit>0 )
	{
		if ( show_axes )
			draw_beamWaist_axes(.52f);
	}
	glTranslatef( 0.0, 0.0, 0.0 );
	glMultMatrixf( beamWaist_rotate );
	if ( flagInit>0 )
	{
		diameter = drawBeamWaist(mt, show_beam);
	}
		sprintf(strDiameter, "Beam Waist: %.2fcm", diameter);	

	glEnable( GL_LIGHTING );
	glutSwapBuffers(); 
}


/***********************************************************************/
/*                           maxIntensityDisplay()                           */
/***********************************************************************/
void maxIntensityDisplay( void )
{
	printf("maxIntensityDisplay ");

	glMatrixMode( GL_PROJECTION );
	glLoadIdentity();
	glFrustum( -xy_aspect*.04, xy_aspect*.04, -.04, .04, .1, 15.0 );

	glMatrixMode( GL_MODELVIEW );

	glLoadIdentity();
	glMultMatrixf( lights_rotation );
	glLightfv(GL_LIGHT0, GL_POSITION, light0_position);

	glLoadIdentity();
	glTranslatef( 0.0, 0.0, -2.6f );
	glTranslatef( maxIntensity_pos[0], maxIntensity_pos[1], -maxIntensity_pos[2] ); 
	glMultMatrixf( view_maxIntensity_rotate );

	glScalef( scale, scale, scale );

	glPushMatrix();
	glTranslatef( 0.0, 0.0, 0.0 );
	glMultMatrixf( maxIntensity_rotate );
	if ( flagInit>0 )
	{
		draw_maxIntensity_axes(.52f);
	}

	glTranslatef( 0.0, 0.0, 0.0 );
	glMultMatrixf( maxIntensity_rotate );
	if ( flagInit>0 )
	{
		drawMaxIntensity(mt, show_max);
	}

	glEnable( GL_LIGHTING );

	glutSwapBuffers(); 
}


/***********************************************************************/
/*                           beamWaistDisplay()                           */
/***********************************************************************/
void beamWaistDisplay( void )
{
	float diameter = 0;
	printf("beamWaistDisplay ");

	glMatrixMode( GL_PROJECTION );
	glLoadIdentity();
	glFrustum( -xy_aspect*.04, xy_aspect*.04, -.04, .04, .1, 15.0 );

	glMatrixMode( GL_MODELVIEW );

	glLoadIdentity();
	glMultMatrixf( lights_rotation );
	glLightfv(GL_LIGHT0, GL_POSITION, light0_position);

	glLoadIdentity();
	glTranslatef( 0.0, 0.0, -2.6f );
	glTranslatef( beamWaist_pos[0], beamWaist_pos[1], -beamWaist_pos[2] ); 
	glMultMatrixf( view_beamWaist_rotate );

	glScalef( scale, scale, scale );

	glPushMatrix();
	glTranslatef( 0.0, 0.0, 0.0 );
	glMultMatrixf( beamWaist_rotate );
	if ( flagInit>0 )
	{
		draw_beamWaist_axes(.52f);
	}

	glTranslatef( 0.0, 0.0, 0.0 );
	glMultMatrixf( beamWaist_rotate );
	if ( flagInit>0 )
	{
		diameter = drawBeamWaist(mt, show_beam);
		sprintf(strDiameter, "Beam Waist: %.2fcm", diameter);
	}

	glEnable( GL_LIGHTING );

	glutSwapBuffers(); 
}


/**********************************************************************************/
/*                                    MAIN                                        */
/**********************************************************************************/
int main(int argc, char* argv[])
{
	int i;
	for(i = 1; i < argc; ++i) 
	{
		if(argv[i][0] == '-') 
		{
			switch(argv[i][1]) 
			{
				case 'c': 	values = initialize(flag, prints, propDistance, rDomain, xDomain, yDomain, tDomain, zDomain, 0, inlambda0, inrmax, intmax, show_cart, inLCR, intaup, inw0, inEnergy, inpf, inchirp, Directory);
						runSimNoGUI(i);
						finalize();
						break;


				case 'g': 	openglinit();		// initializes everything to essentially 0
						/***********************************************************************/
						/*                 Initialize GLUT and Create Windows                  */
						/***********************************************************************/
						glutInit(&argc, argv);
						glutInitDisplayMode( GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH );


						/***********************************************************************/
						/*                      Setup Spatial Window                           */
						/***********************************************************************/
						/*** Create Window/Setup Callbacks***/
						glutInitWindowPosition( 1800, 25 );		// Top Left
						glutInitWindowSize( 580, 500 );
						spatialWindow = glutCreateWindow( "Spatial Intensity" );

						glutDisplayFunc( spatialDisplay );
						GLUI_Master.set_glutReshapeFunc( spatialReshape );  
						GLUI_Master.set_glutKeyboardFunc( myGlutKeyboard );
						GLUI_Master.set_glutSpecialFunc( NULL );
						GLUI_Master.set_glutMouseFunc( myGlutMouse );
						glutMotionFunc( myGlutMotion );
						/*** End Create Window/Setup Callbacks***/

						/*** Add Bottom SubWindow ***/
						spatialSubWindow = GLUI_Master.create_glui_subwindow( spatialWindow, GLUI_SUBWINDOW_BOTTOM );
						spatialSubWindow->set_main_gfx_window( spatialWindow );

						GLUI_Rotation *view_rot_spatial = new GLUI_Rotation(spatialSubWindow, "Rotate", view_spatial_rotate );
						view_rot_spatial->set_spin( 1.0 );
						new GLUI_Column( spatialSubWindow, false );
						GLUI_Translation *trans_xy_spatial = new GLUI_Translation(spatialSubWindow, "XY", GLUI_TRANSLATION_XY, spatial_pos );
						trans_xy_spatial->set_speed( .005 );
						new GLUI_Column( spatialSubWindow, false );
						GLUI_Translation *trans_x_spatial = new GLUI_Translation(spatialSubWindow, "X", GLUI_TRANSLATION_X, spatial_pos );
						trans_x_spatial->set_speed( .005 );
						new GLUI_Column( spatialSubWindow, false );
						GLUI_Translation *trans_y_spatial = new GLUI_Translation(spatialSubWindow, "Y", GLUI_TRANSLATION_Y, &spatial_pos[1]);
						trans_y_spatial->set_speed( .005 );
						new GLUI_Column( spatialSubWindow, false );
						GLUI_Translation *trans_z_spatial = new GLUI_Translation(spatialSubWindow, "Z", GLUI_TRANSLATION_Z, &spatial_pos[2]);
						trans_z_spatial->set_speed( .005 );
						/*** End Bottom SubWindow ***/

						/***** Setup OpenGL lights *****/
						glEnable(GL_LIGHTING);
						glEnable( GL_NORMALIZE );

						glEnable(GL_LIGHT0);
						glLightfv(GL_LIGHT0, GL_AMBIENT, light0_ambient);
						glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_diffuse);
						glLightfv(GL_LIGHT0, GL_POSITION, light0_position);

						glEnable(GL_LIGHT1);
						glLightfv(GL_LIGHT1, GL_AMBIENT, light1_ambient);
						glLightfv(GL_LIGHT1, GL_DIFFUSE, light1_diffuse);
						glLightfv(GL_LIGHT1, GL_POSITION, light1_position);
						/***** End OpenGL lights *****/

						/***** Enable z-buferring *****/
						glEnable(GL_DEPTH_TEST);


						/***********************************************************************/
						/*                      Setup Spectral Window                          */
						/***********************************************************************/
						/*** Create Window/Setup Callbacks***/
						glutInitWindowPosition( 1800, 555 );		// Top Right
						glutInitWindowSize( 580, 500 );
						spectralWindow = glutCreateWindow( "Spectral Distance" );

						glutDisplayFunc( spectralDisplayInit );
						GLUI_Master.set_glutReshapeFunc( spectralReshape );  
						GLUI_Master.set_glutKeyboardFunc( myGlutKeyboard );
						GLUI_Master.set_glutSpecialFunc( NULL );
						GLUI_Master.set_glutMouseFunc( myGlutMouse );
						glutMotionFunc( myGlutMotion );
						/*** End Create Window/Setup Callbacks***/

						/*** Add Bottom SubWindow ***/
						spectralSubWindow = GLUI_Master.create_glui_subwindow( spectralWindow, GLUI_SUBWINDOW_BOTTOM );
						spectralSubWindow->set_main_gfx_window( spectralWindow );

						GLUI_Rotation *view_rot_spectral = new GLUI_Rotation(spectralSubWindow, "Rotate", view_spectral_rotate );
						view_rot_spectral->set_spin( 1.0 );
						new GLUI_Column( spectralSubWindow, false );
						GLUI_Translation *trans_xy_spectral = new GLUI_Translation(spectralSubWindow, "XY", GLUI_TRANSLATION_XY, spectral_pos );
						trans_xy_spectral->set_speed( .005 );
						new GLUI_Column( spectralSubWindow, false );
						GLUI_Translation *trans_x_spectral = new GLUI_Translation(spectralSubWindow, "X", GLUI_TRANSLATION_X, spectral_pos );
						trans_x_spectral->set_speed( .005 );
						new GLUI_Column( spectralSubWindow, false );
						GLUI_Translation *trans_y_spectral = new GLUI_Translation(spectralSubWindow, "Y", GLUI_TRANSLATION_Y, &spectral_pos[1]);
						trans_y_spectral->set_speed( .005 );
						new GLUI_Column( spectralSubWindow, false );
						GLUI_Translation *trans_z_spectral = new GLUI_Translation(spectralSubWindow, "Z", GLUI_TRANSLATION_Z, &spectral_pos[2]);
						trans_z_spectral->set_speed( .005 );
						/*** End Bottom SubWindow ***/

						/***** Setup OpenGL lights *****/
						glEnable(GL_LIGHTING);
						glEnable( GL_NORMALIZE );

						glEnable(GL_LIGHT0);
						glLightfv(GL_LIGHT0, GL_AMBIENT, light0_ambient);
						glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_diffuse);
						glLightfv(GL_LIGHT0, GL_POSITION, light0_position);

						glEnable(GL_LIGHT1);
						glLightfv(GL_LIGHT1, GL_AMBIENT, light1_ambient);
						glLightfv(GL_LIGHT1, GL_DIFFUSE, light1_diffuse);
						glLightfv(GL_LIGHT1, GL_POSITION, light1_position);
						/***** End OpenGL lights *****/

						/***** Enable z-buferring *****/
						glEnable(GL_DEPTH_TEST);


						/***********************************************************************/
						/*                      Setup SpaceTime Window                          */
						/***********************************************************************/
						/*** Create Window/Setup Callbacks***/
						glutInitWindowPosition( 0, 25 );		// Top Right
						glutInitWindowSize( 1920, 500 );
						spacetimeWindow = glutCreateWindow( "Space-Time Intensity" );

						glutDisplayFunc( spacetimeDisplayInit );
						GLUI_Master.set_glutReshapeFunc( spacetimeReshape );  
						GLUI_Master.set_glutKeyboardFunc( myGlutKeyboard );
						GLUI_Master.set_glutSpecialFunc( NULL );
						GLUI_Master.set_glutMouseFunc( myGlutMouse );
						glutMotionFunc( myGlutMotion );
						/*** End Create Window/Setup Callbacks***/

						/*** Add Bottom SubWindow ***/
						spacetimeSubWindow = GLUI_Master.create_glui_subwindow( spacetimeWindow, GLUI_SUBWINDOW_BOTTOM );
						spacetimeSubWindow->set_main_gfx_window( spacetimeWindow );

						GLUI_Rotation *view_rot_spacetime = new GLUI_Rotation(spacetimeSubWindow, "Rotate", view_spacetime_rotate );
						view_rot_spacetime->set_spin( 1.0 );
						new GLUI_Column( spacetimeSubWindow, false );
						GLUI_Translation *trans_xy_spacetime = new GLUI_Translation(spacetimeSubWindow, "XY", GLUI_TRANSLATION_XY, spacetime_pos );
						trans_xy_spacetime->set_speed( .005 );
						new GLUI_Column( spacetimeSubWindow, false );
						GLUI_Translation *trans_x_spacetime = new GLUI_Translation(spacetimeSubWindow, "X", GLUI_TRANSLATION_X, spacetime_pos );
						trans_x_spacetime->set_speed( .005 );
						new GLUI_Column( spacetimeSubWindow, false );
						GLUI_Translation *trans_y_spacetime = new GLUI_Translation(spacetimeSubWindow, "Y", GLUI_TRANSLATION_Y, &spacetime_pos[1]);
						trans_y_spacetime->set_speed( .005 );
						new GLUI_Column( spacetimeSubWindow, false );
						GLUI_Translation *trans_z_spacetime = new GLUI_Translation(spacetimeSubWindow, "Z", GLUI_TRANSLATION_Z, &spacetime_pos[2]);
						trans_z_spacetime->set_speed( .005 );
						/*** End Bottom SubWindow ***/

						/***** Setup OpenGL lights *****/
						glEnable(GL_LIGHTING);
						glEnable( GL_NORMALIZE );

						glEnable(GL_LIGHT0);
						glLightfv(GL_LIGHT0, GL_AMBIENT, light0_ambient);
						glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_diffuse);
						glLightfv(GL_LIGHT0, GL_POSITION, light0_position);

						glEnable(GL_LIGHT1);
						glLightfv(GL_LIGHT1, GL_AMBIENT, light1_ambient);
						glLightfv(GL_LIGHT1, GL_DIFFUSE, light1_diffuse);
						glLightfv(GL_LIGHT1, GL_POSITION, light1_position);
						/***** End OpenGL lights *****/

						/***** Enable z-buferring *****/
						glEnable(GL_DEPTH_TEST);


						/***********************************************************************/
						/*                      Setup Max Intensity Window                          */
						/***********************************************************************/
						/*** Create Window/Setup Callbacks***/
						glutInitWindowPosition( 3080, 555 );		// Top Right
						glutInitWindowSize( 755, 500 );
						maxIntensityWindow = glutCreateWindow( "Max Intensity" );

						glutDisplayFunc( maxIntensityDisplayInit );
						GLUI_Master.set_glutReshapeFunc( maxIntensityReshape );  
						GLUI_Master.set_glutKeyboardFunc( myGlutKeyboard );
						GLUI_Master.set_glutSpecialFunc( NULL );
						GLUI_Master.set_glutMouseFunc( myGlutMouse );
						glutMotionFunc( myGlutMotion );
						/*** End Create Window/Setup Callbacks***/

						/*** Add Bottom SubWindow ***/
						maxIntensitySubWindow = GLUI_Master.create_glui_subwindow( maxIntensityWindow, GLUI_SUBWINDOW_BOTTOM );
						maxIntensitySubWindow->set_main_gfx_window( maxIntensityWindow );

						GLUI_Rotation *view_rot_maxIntensity = new GLUI_Rotation(maxIntensitySubWindow, "Rotate", view_spacetime_rotate );
						view_rot_maxIntensity->set_spin( 1.0 );
						new GLUI_Column( maxIntensitySubWindow, false );
						GLUI_Translation *trans_xy_maxIntensity = new GLUI_Translation(maxIntensitySubWindow, "XY", GLUI_TRANSLATION_XY, maxIntensity_pos );
						trans_xy_maxIntensity->set_speed( .005 );
						new GLUI_Column( maxIntensitySubWindow, false );
						GLUI_Translation *trans_x_maxIntensity = new GLUI_Translation(maxIntensitySubWindow, "X", GLUI_TRANSLATION_X, maxIntensity_pos );
						trans_x_maxIntensity->set_speed( .005 );
						new GLUI_Column( maxIntensitySubWindow, false );
						GLUI_Translation *trans_y_maxIntensity = new GLUI_Translation(maxIntensitySubWindow, "Y", GLUI_TRANSLATION_Y, &maxIntensity_pos[1]);
						trans_y_maxIntensity->set_speed( .005 );
						new GLUI_Column( maxIntensitySubWindow, false );
						GLUI_Translation *trans_z_maxIntensity = new GLUI_Translation(maxIntensitySubWindow, "Z", GLUI_TRANSLATION_Z, &maxIntensity_pos[2]);
						trans_z_maxIntensity->set_speed( .005 );
						/*** End Bottom SubWindow ***/

						/***** Setup OpenGL lights *****/
						glEnable(GL_LIGHTING);
						glEnable( GL_NORMALIZE );

						glEnable(GL_LIGHT0);
						glLightfv(GL_LIGHT0, GL_AMBIENT, light0_ambient);
						glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_diffuse);
						glLightfv(GL_LIGHT0, GL_POSITION, light0_position);

						glEnable(GL_LIGHT1);
						glLightfv(GL_LIGHT1, GL_AMBIENT, light1_ambient);
						glLightfv(GL_LIGHT1, GL_DIFFUSE, light1_diffuse);
						glLightfv(GL_LIGHT1, GL_POSITION, light1_position);
						/***** End OpenGL lights *****/

						/***** Enable z-buferring *****/
						glEnable(GL_DEPTH_TEST);

						/***********************************************************************/
						/*                      Setup Beam Waist Window                          */
						/***********************************************************************/
						/*** Create Window/Setup Callbacks***/
						glutInitWindowPosition( 0, 555 );		// Top Right
						glutInitWindowSize( 1920, 500 );
						beamWaistWindow = glutCreateWindow( "Beam Waist" );

						glutDisplayFunc( beamWaistDisplayInit );
						GLUI_Master.set_glutReshapeFunc( beamWaistReshape );  
						GLUI_Master.set_glutKeyboardFunc( myGlutKeyboard );
						GLUI_Master.set_glutSpecialFunc( NULL );
						GLUI_Master.set_glutMouseFunc( myGlutMouse );
						glutMotionFunc( myGlutMotion );
						/*** End Create Window/Setup Callbacks***/

						/*** Add Bottom SubWindow ***/
						beamWaistSubWindow = GLUI_Master.create_glui_subwindow( beamWaistWindow, GLUI_SUBWINDOW_BOTTOM );
						beamWaistSubWindow->set_main_gfx_window( beamWaistWindow );

						GLUI_Rotation *view_rot_beamWaist = new GLUI_Rotation(beamWaistSubWindow, "Rotate", view_beamWaist_rotate );
						view_rot_beamWaist->set_spin( 1.0 );
						new GLUI_Column( beamWaistSubWindow, false );
						GLUI_Translation *trans_xy_beamWaist = new GLUI_Translation(beamWaistSubWindow, "XY", GLUI_TRANSLATION_XY, beamWaist_pos );
						trans_xy_beamWaist->set_speed( .005 );
						new GLUI_Column( beamWaistSubWindow, false );
						GLUI_Translation *trans_x_beamWaist = new GLUI_Translation(beamWaistSubWindow, "X", GLUI_TRANSLATION_X, beamWaist_pos );
						trans_x_beamWaist->set_speed( .005 );
						new GLUI_Column( beamWaistSubWindow, false );
						GLUI_Translation *trans_y_beamWaist = new GLUI_Translation(beamWaistSubWindow, "Y", GLUI_TRANSLATION_Y, &beamWaist_pos[1]);
						trans_y_beamWaist->set_speed( .005 );
						new GLUI_Column( beamWaistSubWindow, false );
						GLUI_Translation *trans_z_beamWaist = new GLUI_Translation(beamWaistSubWindow, "Z", GLUI_TRANSLATION_Z, &beamWaist_pos[2]);
						trans_z_beamWaist->set_speed( .005 );
						/*** End Bottom SubWindow ***/

						/***** Setup OpenGL lights *****/
						glEnable(GL_LIGHTING);
						glEnable( GL_NORMALIZE );

						glEnable(GL_LIGHT0);
						glLightfv(GL_LIGHT0, GL_AMBIENT, light0_ambient);
						glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_diffuse);
						glLightfv(GL_LIGHT0, GL_POSITION, light0_position);

						glEnable(GL_LIGHT1);
						glLightfv(GL_LIGHT1, GL_AMBIENT, light1_ambient);
						glLightfv(GL_LIGHT1, GL_DIFFUSE, light1_diffuse);
						glLightfv(GL_LIGHT1, GL_POSITION, light1_position);
						/***** End OpenGL lights *****/

						/***** Enable z-buferring *****/
						glEnable(GL_DEPTH_TEST);



						/***********************************************************************/
						/*                      Setup Temporal Window                          */
						/***********************************************************************/
						/*** Create Window/Setup Callbacks***/
						glutInitWindowPosition( 2500, 555 );		// Bottom Left
						glutInitWindowSize( 580, 500 );
						temporalWindow = glutCreateWindow( "Temporal Intensity" );

						glutDisplayFunc( redrawTemporal );
						GLUI_Master.set_glutReshapeFunc( reshapeTemporal );  
						GLUI_Master.set_glutKeyboardFunc( myGlutKeyboard );
						GLUI_Master.set_glutSpecialFunc( NULL );
						GLUI_Master.set_glutMouseFunc( myGlutMouse );
						glutMotionFunc( myGlutMotion );
						/*** End Create Window/Setup Callbacks***/

						/*** Add Bottom SubWindow ***/
						temporalBottomSubWIndow = GLUI_Master.create_glui_subwindow( temporalWindow, GLUI_SUBWINDOW_BOTTOM );
						temporalBottomSubWIndow->set_main_gfx_window( temporalWindow );

						GLUI_Rotation *view_rot = new GLUI_Rotation(temporalBottomSubWIndow, "Objects", view_rotate );
						view_rot->set_spin( 1.0 );
						new GLUI_Column( temporalBottomSubWIndow, false );
						GLUI_Translation *trans_xy = 
						new GLUI_Translation(temporalBottomSubWIndow, "XY", GLUI_TRANSLATION_XY, temporal_pos );
						trans_xy->set_speed( .005 );
						new GLUI_Column( temporalBottomSubWIndow, false );
						GLUI_Translation *trans_x = 
						new GLUI_Translation(temporalBottomSubWIndow, "X", GLUI_TRANSLATION_X, temporal_pos );
						trans_x->set_speed( .005 );
						new GLUI_Column( temporalBottomSubWIndow, false );
						GLUI_Translation *trans_y = 
						new GLUI_Translation( temporalBottomSubWIndow, "Y", GLUI_TRANSLATION_Y, &temporal_pos[1] );
						trans_y->set_speed( .005 );
						new GLUI_Column( temporalBottomSubWIndow, false );
						GLUI_Translation *trans_z = 
						new GLUI_Translation( temporalBottomSubWIndow, "Z", GLUI_TRANSLATION_Z, &temporal_pos[2] );
						trans_z->set_speed( .005 );
						/*** End Bottom SubWindow ***/


						/***********************************************************************/
						/*                      Setup Real-Time Window                         */
						/***********************************************************************/
						/*** Create Window/Setup Callbacks***/
						glutInitWindowPosition( 2500, 292 );		// Bottom Right
						glutInitWindowSize( 580, 233 );
						realtimeWindow = glutCreateWindow( "Real-Time" );

						glutDisplayFunc( realtimeDisplay );
						GLUI_Master.set_glutKeyboardFunc( myGlutKeyboard );
						GLUI_Master.set_glutSpecialFunc( NULL );
						GLUI_Master.set_glutMouseFunc( myGlutMouse );
						/*** End Create Window/Setup Callbacks***/

						realtimeBottomSubWindow = GLUI_Master.create_glui_subwindow( realtimeWindow, GLUI_SUBWINDOW_BOTTOM );
						realtime_bottom_panel = new GLUI_Panel(realtimeBottomSubWindow, "Control" );

						//########## Add Bottom Panel ##########//
						/***** Add Buttons *****/
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						new GLUI_Button( realtime_bottom_panel, "Propagate", PROPAGATE, control_cb );
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						new GLUI_Button( realtime_bottom_panel, "Decay", DECAY, control_cb );
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						realtimeBottomSubWindow->add_column_to_panel(realtime_bottom_panel, false);
						/***** End Buttons *****/
						//########## End Bottom Panel ##########//


						/***********************************************************************/
						/*                      Create Control Window                          */
						/***********************************************************************/
						controlWindow = GLUI_Master.create_glui( "Configuration", 0, 0/*2500*/, 25 );
						control_panel = new GLUI_Panel(controlWindow, "" );
						properties_panel = new GLUI_Panel(control_panel, "Laser Parameters" );

						/**** Add listbox ****/
						GLUI_Listbox *pulseList = new GLUI_Listbox( properties_panel, "Pulse:", &curr_string );

						for( i=0; i<1; i++ )
							pulseList->add_item( i, pulseString_list );
						/**** End listbox ****/

						/**** Add Spinners ****/
						GLUI_Spinner *fwhmSpinner = new GLUI_Spinner( properties_panel, "Pulse Width(fs):   ", &intaup);
						fwhmSpinner->set_int_limits( 1, 600 );
						fwhmSpinner->set_alignment( GLUI_ALIGN_LEFT );
						GLUI_Spinner *wavelengthSpinner = new GLUI_Spinner( properties_panel, "Wavelength(nm):", &inlambda0);
						wavelengthSpinner->set_int_limits( 1, 1000 );
						wavelengthSpinner->set_alignment( GLUI_ALIGN_LEFT );
						GLUI_Spinner *lcrSpinner = new GLUI_Spinner( properties_panel, "Lens Radius(cm):", &inLCR);
						lcrSpinner->set_int_limits( 1, 1000 );
						lcrSpinner->set_alignment( GLUI_ALIGN_LEFT );
						GLUI_Spinner *chirpSpinner = new GLUI_Spinner( properties_panel, "Chirp(+or-):", &inchirp);
						chirpSpinner->set_float_limits( -100.0, 1000.0 );
						chirpSpinner->set_alignment( GLUI_ALIGN_LEFT );
						GLUI_Spinner *energySpinner = new GLUI_Spinner( properties_panel, "Energy(mJ):", &inEnergy);
						energySpinner->set_float_limits( 0, 10000 );
						energySpinner->set_alignment( GLUI_ALIGN_LEFT );
						GLUI_Spinner *pfSpinner = new GLUI_Spinner( properties_panel, "Power Factor:", &inpf);
						pfSpinner->set_int_limits( 0, 1000 );
						pfSpinner->set_alignment( GLUI_ALIGN_LEFT );
						GLUI_Spinner *w0Spinner = new GLUI_Spinner( properties_panel, "Beam Waist(mm):", &inw0);
						w0Spinner->set_int_limits( 0, 1000 );
						w0Spinner->set_alignment( GLUI_ALIGN_LEFT );
						/**** End Spinners ****/

						controlWindow->add_column_to_panel(control_panel, true);

						/*** Add rollouts (checkboxes) ***/
						GLUI_Rollout *terms = new GLUI_Rollout(control_panel, "Terms", true );
						new GLUI_Checkbox( terms, "Diffraction", &show_diffraction );
						new GLUI_Checkbox( terms, "Dispersion", &show_dispersion );
						new GLUI_Checkbox( terms, "Self-Phase Modulation", &show_spm );
						new GLUI_Checkbox( terms, "Self-Steepening", &show_ss );
						new GLUI_Checkbox( terms, "Multi-Photon Ionization", &show_mpi );
						new GLUI_Checkbox( terms, "Plasma/Ionization", &show_plasma );
						new GLUI_Checkbox( terms, "Focussing Lens", &show_lens );
						/*** End rollouts (checkboxes) ***/

						controlWindow->add_column_to_panel(control_panel, true);

						/*** Add rollouts (checkboxes) ***/
						GLUI_Rollout *numerical_panel = new GLUI_Rollout(control_panel, "Numerical Parameters", false );
						GLUI_Spinner *timeSpinner = new GLUI_Spinner( numerical_panel, "T Points:", &tDomain);
						timeSpinner->set_int_limits( 2, 5120 );
						timeSpinner->set_alignment( GLUI_ALIGN_LEFT );
						GLUI_Spinner *rSpinner = new GLUI_Spinner( numerical_panel, "R Points:", &rDomain);
						rSpinner->set_int_limits( 0, 5120 );
						rSpinner->set_alignment( GLUI_ALIGN_LEFT );
						GLUI_Spinner *xSpinner = new GLUI_Spinner( numerical_panel, "X Points:", &xDomain);
						xSpinner->set_int_limits( 0, 5120 );
						xSpinner->set_alignment( GLUI_ALIGN_LEFT );
						GLUI_Spinner *ySpinner = new GLUI_Spinner( numerical_panel, "Y Points:", &yDomain);
						ySpinner->set_int_limits( 0, 5120 );
						ySpinner->set_alignment( GLUI_ALIGN_LEFT );
						GLUI_Spinner *zstepSpinner = new GLUI_Spinner( numerical_panel, "Z Points:", &zDomain);
						zstepSpinner->set_int_limits( 1, 10000000 );
						zstepSpinner->set_alignment( GLUI_ALIGN_LEFT );
						GLUI_Spinner *distanceSpinner = new GLUI_Spinner( numerical_panel, "Distance(cm):", &propDistance);
						distanceSpinner->set_int_limits( 1, 1000000 );
						distanceSpinner->set_alignment( GLUI_ALIGN_LEFT );
						GLUI_Spinner *rmaxSpinner = new GLUI_Spinner( numerical_panel, "R Max(mm):", &inrmax);
						rmaxSpinner->set_int_limits( 1, 1000000 );
						rmaxSpinner->set_alignment( GLUI_ALIGN_LEFT );
						GLUI_Spinner *tmaxSpinner = new GLUI_Spinner( numerical_panel, "T Max(fs):", &intmax);
						tmaxSpinner->set_int_limits( 1, 1000000 );
						tmaxSpinner->set_alignment( GLUI_ALIGN_LEFT );
						/*** End rollouts (checkboxes) ***/

						controlWindow->add_column_to_panel(control_panel, true);

						/*** Add rollouts (checkboxes) ***/
						GLUI_Rollout *features_panel = new GLUI_Rollout(control_panel, "Program Features", true );
						new GLUI_Checkbox( features_panel, "Cylindrical Coordinates", &show_cyl );
						new GLUI_Checkbox( features_panel, "Cartesian Coordinates", &show_cart );
						new GLUI_Checkbox( features_panel, "Input Power Factor", &input_pf );
						new GLUI_Checkbox( features_panel, "Input Energy", &input_energy );
						new GLUI_Checkbox( features_panel, "Print Spatial Domain", &print_spatDom );
						new GLUI_Checkbox( features_panel, "Print Plasma Domain", &print_plasDom );
						new GLUI_Checkbox( features_panel, "Print Spatial Video", &print_spatVid );
						new GLUI_Checkbox( features_panel, "Print Plasma Video", &print_plasVid );
						new GLUI_Checkbox( features_panel, "Print Plasma Decay", &print_plasSim );
						/*** End rollouts (checkboxes) ***/

						controlWindow->add_column_to_panel(control_panel, true);

						/*** Add rollouts (checkboxes) ***/
						GLUI_Rollout *windows_panel = new GLUI_Rollout(control_panel, "Window Selection", true );
						new GLUI_Checkbox( windows_panel, "Spatial Intensity", &show_spatial );
						new GLUI_Checkbox( windows_panel, "Temporal Intensity", &show_temporal );
						new GLUI_Checkbox( windows_panel, "Spectral Distance", &show_spectral );
						new GLUI_Checkbox( windows_panel, "Max Intensity", &show_max );
						new GLUI_Checkbox( windows_panel, "Beam Waist", &show_beam );
						new GLUI_Checkbox( windows_panel, "Space-Time Intensity", &show_space );
						/*** End rollouts (checkboxes) ***/

						controlWindow->add_column_to_panel(control_panel, true);

						/*** Add rollouts (checkboxes) ***/
						GLUI_Rollout *plasma_panel = new GLUI_Rollout(control_panel, "Plasma Decay Simulation", true );
						GLUI_Spinner *plasmaxSpinner = new GLUI_Spinner( plasma_panel, "Duration(ns):", &tPlasMax);
						plasmaxSpinner->set_float_limits( 2, 5120 );
						GLUI_Spinner *plasdomainSpinner = new GLUI_Spinner( plasma_panel, "T Points:", &tPlasDomain);
						plasdomainSpinner->set_int_limits( 2, 5120 );
						GLUI_Spinner *decaySpinner = new GLUI_Spinner( plasma_panel, "Decay Constant(e-9):", &tDecay);
						decaySpinner->set_float_limits( 2, 5120 );
						/*** End rollouts (checkboxes) ***/

						new GLUI_Button( controlWindow, "Initiate", INITIALIZE, control_cb );

						/***********************************************************************/
						/*                     And The Rest....                                */
						/***********************************************************************/
						printf( "USPL Version: %3.1f\n", version );
						printf("rDomain:%d, tDomain:%d\n", rDomain, tDomain);

						glutMainLoop();
						return EXIT_SUCCESS;
						break;
			}
		}
	}
}
